using PyPlot

#topple with reflecting boundary conditions
function one_topple_sym!(S,T)
	isTopple = false; 
	N = size(S,1);
	S_copy = copy(S); 
	for x in 2:N
		for y in 2:N
			z = floor(max(S_copy[x,y],0)/4);
			if(x == N && y < N)
				S[x,y] -= 3*z;
				S[x-1,y]+=z;
				S[x,y+1]+=z;
				S[x,y-1]+=z; 
				T[x,y]+=z; 
			elseif(y == N && x < N)
				S[x,y] -= 3*z;
				S[x+1,y] += z; 
				S[x-1,y]+=z;
				S[x,y-1]+=z; 
				T[x,y]+=z; 
			elseif(x == N && y == N)
				S[x,y] -= 2*z;
				S[x-1,y]+=z;
				S[x,y-1]+=z; 
				T[x,y]+=z; 
			else
				S[x,y] -= 4*z;
				S[x+1,y] += z; 
				S[x-1,y]+=z;
				S[x,y+1]+=z;
				S[x,y-1]+=z; 
				T[x,y]+=z; 
			end
			if(z > 0) isTopple = true; end; 
		end
	end
	return isTopple;
end
function one_topple_1D_sym!(S,T)
	isTopple = false; 
	N = size(S,1);
	S_copy = copy(S); 
	for x in 2:N
		z = floor(max(S_copy[x],0)/2);
		z = min(z,1);
		T[x]+=z;
		if(x == N)
			S[x]-=z;
			S[x-1]+=z;
		else
			S[x]-=2*z;
			S[x-1]+=z;
			S[x+1]+=z;
		end
		if(z > 0) isTopple = true; end; 
	end
	return isTopple;
end


function one_topple_3D!(S,T)
	isTopple = false; 
	N = size(S,1);
	S_copy = copy(S); 
	for x in 2:(N-1)
		for y in 2:(N-1)
			for w in 2:(N-1)
				#z = min(floor(max(S_copy[x,y],0)/4),1);
				z = floor(max(S_copy[x,y,w],0)/6);
				S[x,y,w] -= 6*z;
				S[x+1,y,w] += z; 
				S[x-1,y,w]+=z;
				S[x,y+1,w]+=z;
				S[x,y-1,w]+=z; 
				S[x,y,w+1]+=z; 
				S[x,y,w-1]+=z; 
				T[x,y,w]+=z; 
				if(z > 0) isTopple = true; end; 
			end
		end
	end
	return isTopple;
end


z = []; #last time you topple twice
z2 = []; #first time you reach M on boundary
z3 = []; #stabilizing time
z4 = []; #last time you have self similarity
for M in 2:1:20
	MM = M-1; 
	println(M)

	kk = 1
	A = (2*2+kk)*ones(M,M);
	A[1,:]=-Inf;
	A[:,1]=-Inf;
	T = zeros(A);


	A_small = copy(A[1:M-1,1:M-1])
	T_small = zeros(A_small);



	TT = zeros(T); 
	isTopple2 = one_topple_sym!(A,TT)
	T = TT; 

	one_topple_sym!(A_small,T_small)

	TT_prev = copy(TT); 
	isTopple2 = true; 
	num_iters = 1; 

	max_same = -Inf; 
	isPushed = false; 

	max_sim = -Inf; 

	while(isTopple2)
		TT = zeros(T); 
		isTopple2 = one_topple_sym!(A,TT)
		if(maximum(TT_prev + TT) == 2)
			max_same = num_iters;
			#push!(z, num_iters)
			#break;
		end
		if(maximum(T[2,:]) == MM && !isPushed)
			isPushed = true; 
			push!(z2, num_iters)
		end
		if(T[1:M-1,1:M-1] ==T_small)
			max_sim = num_iters
		end


		one_topple_sym!(A_small,T_small)

		#if(maximum(TT_prev + TT) < 2)
		#	push!(z,num_iters)
		#	break;
		#end
		T = T + TT; 
		TT_prev = TT; 
		num_iters+=1; 
	end
	push!(z3, num_iters-1)
	push!(z, max_same)
	push!(z4, max_sim)
end
display([z4 z])
#println(all(z3[1:end-1].>=z[2:end]))




