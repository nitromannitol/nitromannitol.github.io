<!DOCTYPE html>
<meta charset="utf-8">


<!-- load the plotly.js and math.js libraries -->      

<head>
  <title> Kuwait COVID-19 Forecasts </title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-53592269-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-53592269-3');
</script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://unpkg.com/mathjs@6.6.1/dist/math.min.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://d3js.org/d3.v5.min.js"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/css/bootstrap-multiselect.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<script src="https://code.jquery.com/jquery-2.2.0.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/js/bootstrap-multiselect.js"></script>



<style> /* set the CSS */
body { 
  margin-left: 20px;
}
.p_class { 
  margin-top: 20px;
  margin-left: 20px;
  margin-right: 20px;
  border: 1px solid black ;
}
/* hides the svg dom element that has the click handler responsible for toggling */
#plotdiv .legend .traces:nth-of-type(1) .legendtoggle {
   display: none;
}
/* just for presentation: shows the default cursor insted of the text cursor */
#plotdiv .legend .traces:nth-of-type(2) .legendtext {
   cursor: default;
}
</style>


</head>




<body>



<p class = "p_class"> Forecasts updated July 05, 2020. 
  Click the legend on the right to remove or display each forecast.
  Use the slider bars to see past forecasts and their performace. 
</p>



<div class="plot" id="forecast_div">

</div>



<div class="plot" id="rt_div">

</div>








<script>




function unique ( array ) {
    return array.filter(function(a){
        return !this[a] ? this[a] = true : false;
    }, {});
}



function makeplot() {
   Plotly.d3.csv("model_forecasts.csv", function(data1){ 
    Plotly.d3.csv("model_r.csv", function(data2){ 
      Plotly.d3.csv("https://covid.ourworldindata.org/data/ecdc/total_deaths.csv", function(data3){
      processData(data1,data2,data3)
      });
    });
  });
};

//https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/ecdc/total_cases_per_million.csv

// data3 is the total deaths repo
  
function processData(data1,data2,data3) {
  var dates = [];
  var total_count = [];
  for (var i=0; i<data3.length; i++) {
    row = data3[i];
    if(row["Kuwait"] > 0){
        total_count.push(row["Kuwait"])
      // console.log(row)
         dates.push( row["date"] );
    };
  }
  //console.log(dates)
  //console.log(total_count)

  var forecast_dates  = [];
  var forecast_titles = [];

  var forecastTitles = d3.keys(data2[0])
 // console.log(forecastTitles)
  date_name = forecastTitles[0];
  forecastTitles = forecastTitles.slice(1,forecastTitles.length+1);
  //console.log(forecastTitles)
  for (var i=0; i<data2.length; i++) {
    row = data2[i];
    forecast_dates.push(row[date_name])
  }
  //console.log(forecast_dates)

  makePlotly(dates,total_count, data1,data2);
}

function median(values){
  if(values.length ===0) return 0;

  values.sort(function(a,b){
    return a-b;
  });

  var half = Math.floor(values.length / 2);

  if (values.length % 2)
    return values[half];

  return (values[half - 1] + values[half]) / 2.0;
}

function generateRPlot(r_data){
//  console.log(r_data)

  curr_model = r_data[0]["model"]
  yy = []
  xx = []
  val2 = 0; 
  data = []; // will hold all the traces


  for(var i = 0; i < r_data.length; i++){
    row = r_data[i]
    model_name = row["model"]
    if(model_name != curr_model){
      //console.log(curr_model)
      // append the data so far to the current frame
       var trace1 = {
          x: xx, 
          y: yy,
          name:  curr_model, 
          mode: 'lines',
          type: 'scatter',
          line: {
          dash: 'dot'
        } 
      };
      data.push(trace1);
      curr_model = model_name
      yy = []
      xx = []
    };
    val2 = Math.max(val2, row["point"])
    yy.push(row["point"])
    xx.push(row["date"])
  };

  // push the last model
  var trace1 = {
  x: xx, 
  y: yy,
  name:  curr_model,
  mode: 'lines',
  type: 'scatter',
 line: {
      dash: 'dot'
    }
  }
  data.push(trace1);
  val11 = xx[xx.length-1];
  val10 = "2020-03-08"; // first day of reported Rt
  //console.log(data)


  var layout = {
    title: {
      text:'Reproduction number estimates',
      font: {
        family: 'Arial',
        size: 15
      },
      xref: 'paper',
    },

     legend: {
      //orientation: 'd',
      y: 0.5,
      yref: 'paper',
      font: {
        family: 'Arial',
        size: 15
      },
    bgcolor: '#E2E2E2',
    bordercolor: '#FFFFFF',
    borderwidth: 2
    },
  yaxis: {
    title: {
      text: 'Estimated Rt',
      font: {
        family: 'Arial',
        size: 18,
        color: '#7f7f7f'
      }
    }
  }, 
  shapes: [
  ]
  };



  // add vertical line corresponding to update day
  val1 =  { type: 'line',
    x0: val11,
    y0: 0,
    x1: val11,
    y1: val2,
    line: {
      color: 'rgb(1, 1, 1)',
      width: 1
    }
  };

  // add horizontal line corresponding to Rt = 1
  val2 =  { type: 'line',
    x0: val10,
    y0: 1,
    x1: val11,
    y1: 1,
    line: {
      color: 'rgb(0, 0, 1)',
      width: 0.5
    //  dash: 'dash'
    }
  };

  layout.shapes.push(val1)
  layout.shapes.push(val2)


  Plotly.newPlot('rt_div', data, layout)
}


function makePlotly(dates, total_count, forecast_data, r_data){
   generateRPlot(r_data)



  // get all unique forecast dates
  // get all unique models
  forecast_dates = []
  model_names = []
  for(var i =0; i < forecast_data.length; i++){
    row = forecast_data[i]; 
    forecast_dates.push(row["forecast_date"]);
    model_names.push(row["model"])
  }
  forecast_dates = unique(forecast_dates).sort()
  model_names = unique(model_names)

  //initialize the sliderSteps
  var sliderSteps = [];
    for (ii = 0; ii < forecast_dates.length; ii++) {
      sliderSteps.push({
        method: 'animate',
        label: forecast_dates[ii],
        args: [[forecast_dates[ii]], {
          frame: {duration: 50, redraw: false, mode: "immediate"},
        }]
      });
    }


  // each frame corresponds to a forecast date
  // with the 6 week future cases

  var frames = [];
  for(var ii = 0; ii < forecast_dates.length; ii++){


    var max_pred = 0; // this will be our maximum range
    data = []; // current frame data
    forecast_date = forecast_dates[ii]; 

    dates_prev = [];
    y_prev = [];
    y_future = [];
    dates_future = [];


    six_week_date = new Date(forecast_date)
    six_week_date.setDate(six_week_date.getDate()+42)
    six_week_date = six_week_date.toISOString();
    res = six_week_date.split("T")
    six_week_date = res[0]

    six_week_date_pad = new Date(forecast_date)
    six_week_date_pad.setDate(six_week_date_pad.getDate()+45)
    six_week_date_pad = six_week_date_pad.toISOString();
    res = six_week_date_pad.split("T")
    six_week_date_pad = res[0]

    for(jj = 0; jj < dates.length; jj++){
      if(dates[jj] <= forecast_date){
          dates_prev.push(dates[jj])
          y_prev.push(total_count[jj])
        }
      else if (dates[jj] <= six_week_date){
        dates_future.push(dates[jj])
        y_future.push(total_count[jj]) 
      };
    }
    max_pred = Math.max(max_pred, y_future[y_future.length-1])



    // past cases
    var trace1 = {
      x: dates_prev,
      y: y_prev,
      name: "Reported",
      showlegend: false,
      type: 'scatter',
      mode: 'lines',
      line: {
        color: "black",
        width: 3
      }
    }
    data.push(trace1)

    // future cases
    var trace2 = {
      x: dates_future,
      y: y_future,
      showlegend: false,
      name: "Future reported",
      type: 'scatter',
      mode: 'lines',
      line: {
        color: "gray",
        width: 1,
        dash: 'dashdot'
      }
    };
    data.push(trace2)

    // line marking current day
    var trace3 = {
      x: [forecast_date, forecast_date], 
      y: [0, y_prev[y_prev.length-1]],
      mode: 'lines',
      type: 'scatter',
      showlegend: false,
      hoverinfo: 'skip',
      line: {
        color: "black",
        width: 0.5
      }
    }
    data.push(trace3)

    curr_model = forecast_data[0]["model"]
    yy = []
    xx = []

    for(var i = 0; i < forecast_data.length; i++){
      row = forecast_data[i]; 
      model_name = row["model"]
      curr_forecast_date = row["forecast_date"]
      if(curr_forecast_date != forecast_date){
        continue;
      }
      target_date = row["target_week_end_date"]

      if(model_name != curr_model){
        // append the data so far to the current 
        // frame
        var trace1 = {
          x: xx, 
          y: yy,
          name:  curr_model, 
          mode: 'lines+markers',
          type: 'scatter'
        };
        data.push(trace1);
        if(yy.length > 0){
          max_pred = Math.max(max_pred, yy[yy.length-1])
        }
        curr_model = model_name
        yy = []
        xx = []
      };
      yy.push(row["point"])
      xx.push(target_date)
    }

       if(yy.length > 0){
          max_pred = Math.max(max_pred, yy[yy.length-1])
        }
    // push the last model
    var trace1 = {
      x: xx, 
      y: yy,
      name:  curr_model, 
      mode: 'lines+markers',
      type: 'scatter'
    };
    data.push(trace1);

    var layout = {
    title: {
        text:'COVID-19 Kuwait National Forecasts',
        font: {
          family: 'Arial',
          size: 24
        },
        xref: 'paper',
      },
       legend: {
          y: 0.5,
          yref: 'paper',
          font: {
            family: 'Arial',
            size: 15
          },
        bgcolor: '#E2E2E2',
        bordercolor: '#FFFFFF',
        borderwidth: 2
      },
       xaxis: {
        type: 'date',
        //autorange: true,
        range: ["2020-04-05", six_week_date_pad],
        showgrid: true
      },
      yaxis: {
        range: [0, max_pred+20],
        showgrid: true
      },
      sliders: [{
      active:ii,
      currentvalue: {
        visible: true,
        prefix: 'Forecast week: ',
        xanchor: 'left',
        font: {size: 20, color: '#666'}
      },
      steps: sliderSteps
    }]
    }
    //console.log(forecast_date)
   // console.log(max_pred)

    curr_frame = {name:forecast_date, data:data, layout:layout}
    // push the current frame to the frames vector
    frames.push(curr_frame)
};
//console.log(frames)



function copy(aObject) {
  if (!aObject) {
    return aObject;
  }

  let v;
  let bObject = Array.isArray(aObject) ? [] : {};
  for (const k in aObject) {
    v = aObject[k];
    bObject[k] = (typeof v === "object") ? copy(v) : v;
  }

  return bObject;
}


  // Create the plot starting at the 
  // last slider must copy otherwise problems happen!
  data_copy = copy(frames[frames.length-1].data)
  layout_copy = copy(frames[frames.length-1].layout)
  Plotly.newPlot('forecast_div', {
    data: data_copy, 
    layout: layout_copy,
    frames: frames,
    responsive: true, 
  });

};

makeplot()

</script>
</body>



<hr>
Models make various assumptions about levels of social distancing and other interventions. 
See model descriptions below for details. 
We keep track of model performance week-to-week by computing the absolute normalized error of each prediction
against the true number of deaths. 


<hr>


<div class="tablediv" id="tablediv">

</div>




<script>
// create the table

var values = [
      ["Geneva","IHME", "Imperial","LANL","MIT", "USC", "YYG"],
      [7.2,10.7,14.0,11.8,20.4,6.8,12.8],
      [NaN,29.9,NaN,28.5,NaN,NaN,30.9],
      [NaN,62.5,NaN,45,NaN,NaN,54.6]
]

var headerColor = "grey";
var rowBestColor = "lightblue";
var rowWorstColor = "red";
var rowColor = "white";

var data = [{
  type: 'table',
  header: {
    values: [["<b>Model</b>"], 
    ["<b>One week ahead median prediction error</b>"],
    ["<b>Three week ahead median prediction error</b>"], 
    ["<b>Six week ahead median prediction error</b>"]
    ],
    align: "center",
    line: {width: 1, color: 'black'},
    fill: {color: headerColor},
    font: {family: "Arial", size: 13, color: "white"}
  },
  cells: {
    values: values,
    align: "center",
    line: {color: "black", width: 1},
    //fill: {color: [[rowBestColor,rowColor,rowColor,rowColor,
    //          rowColor,rowColor,rowWorstColor]]},
    font: {family: "Arial", size: 12, color: ["black"]}
  }
}]

var layout = {
  title: "Historic median prediction errors"
}

Plotly.newPlot('tablediv', data, layout);


</script>


<hr>

<h2><a id="what-forecasts-predict" class="onThisPageAnchor" title="What the Forecasts Aim to Predict"></a>What the Forecasts Aim to Predict</h2>

<p>Forecasts based on statistical or mathematical models aim to predict changes in national level cumulative reported COVID-19 deaths for the next four weeks. Forecasting teams predict numbers of deaths using different types of data (e.g., COVID-19 data, demographic data, mobility data), methods (see below), and estimates of the impacts of interventions (e.g.&nbsp;social distancing, use of face coverings).</p>
<h2><a id="working" class="onThisPageAnchor" title="Working to Bring Together Forecasts for COVID-19 Deaths in Kuwait"></a>Working to Bring Together Forecasts for COVID-19 Deaths in Kuwait</h2>
<p> These forecasts have been developed independently and shared publicly. It is important to bring these forecasts together to help understand how they compare with each other and how much uncertainty there is about what may happen in the upcoming four weeks.</p>



<h3><a id="imperial-college-london"></a><a href="https://mrc-ide.github.io/covid19-short-term-forecasts/index.html" class="tp-link-policy" data-domain-ext="io">Imperial College, London<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> Imperial</p>
<p><strong>Intervention Assumptions: </strong>These projections do not make specific assumptions about which interventions have been implemented or will remain in place.</p>
<p><strong>Methods:</strong> Ensembles of mechanistic transmission models, fit to different parameter assumptions.</p>
<p><strong>Output:</strong> 1 week ahead deaths, infections, Rt</p>



<h3><a href="https://covid19.healthdata.org/united-states-of-america" class="tp-link-policy" data-domain-ext="org">Institute of Health Metrics and Evaluation<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> IHME</p>
<p><strong>Intervention assumptions: </strong>Projections are adjusted to reflect differences in aggregate population mobility and community mitigation policies.</p>
<p><strong>Methods:</strong> Combination of a mechanistic disease transmission model and a curve-fitting approach</p>
<p><strong>Output:</strong> Deaths, infections, testing, hospital resource use, social distancing</p>



<h3><a id="los-alamos-lab"></a><a href="https://covid-19.bsvgateway.org/" class="tp-link-policy" data-domain-ext="org">Los Alamos National Laboratory<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> LANL</p>
<p><strong>Intervention assumptions: </strong>This model assumes that currently implemented interventions and corresponding reductions in transmission will continue, resulting in an overall decrease in the growth rate of COVID-19. Over the course of the forecast, the model assumes that the rate of growth will decrease over time.</p>
<p><strong>Methods</strong><br>
Statistical dynamical growth model accounting for population susceptibility</p>
<p><strong>Output:</strong> Deaths, infections</p>




<h3><a id="mit"></a><a href="https://www.covidanalytics.io/projections" class="tp-link-policy" data-domain-ext="io">Massachusetts Institute of Technology<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name: </strong>MIT</p>
<p><strong>Intervention Assumptions:</strong> The projections assume that current interventions will remain in place indefinitely.</p>
<p><strong>Methods: </strong>SEIR model fit to reported death and case counts.</p>
<p><strong>Output:</strong> Deaths, infections, active infections, hospitalizations, policy changes</p>



<h3><a id="usc"></a><a href="https://scc-usc.github.io/ReCOVER-COVID-19/" class="tp-link-policy" data-domain-ext="io">University of Southern California<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name: </strong>USC</p>
<p><strong>Intervention Assumptions:</strong> These projections assume that current interventions will remain unchanged during the forecasted period.</p>
<p><strong>Methods:&nbsp;</strong>SIR Model.</p>
<p><strong>Output:</strong> Deaths, infections, R_t</p>


<h3><a id="geneva"></a><a href="https://renkulab.shinyapps.io/COVID-19-Epidemic-Forecasting/" class="tp-link-policy" data-domain-ext="io">University of Geneva / Swiss Data Science Center<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> Geneva</p>
<p><strong>Intervention assumptions: </strong>The projections assume that social distancing policies in place at the date of calibration are extended for the future weeks.</p>
<p><strong>Methods</strong><br>
Exponential and linear statistical models fit to the recent growth rate of cumulative deaths.</p>
<p><strong>Output:</strong> Deaths, infections, R_t</p>


<h3><a id="yyg"></a><a href="http://covid19-projections.com/about/" class="tp-link-policy" data-domain-ext="com">Youyang Gu (COVID-Projections)<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> YYG</p>
<p><strong>Intervention assumptions:</strong> The model accounts for reopenings and their impact on infections and deaths.</p>
<p><strong>Methods</strong><br>
SEIS mechanistic model.</p>
</div></div><div class="row "><div class="col-md-12"><div class="row-fluid">
  <div class="vc_empty_space col-12 pb-3"><span class="vc_empty_space_inner"></span></div>
</div>
</div></div></div>
<p><strong>Output:</strong> Deaths, infections, R_t</p>





<hr>

   <footer>
    Please email 
      <a href = "mailto: ahmedmb@gmail.com">here</a> if you would like 
      your projections to be included weekly. Forecasts 
      must be submitted by Sunday at 6 pm AST in order to be included
      in the weekly update.
    </footer>






