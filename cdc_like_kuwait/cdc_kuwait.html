<!DOCTYPE html>
<meta charset="utf-8">


<!-- load the plotly.js and math.js libraries -->      

<head>
  <title> Kuwait COVID-19 Aggregate Forecasts </title>


<script src="java_scripts/plotly-latest.min.js"></script>
<script src="java_scripts/math.min.js"></script>
<script id="MathJax-script" async src="java_scripts/tex-mml-chtml.js"></script>
<script src="java_scripts/d3.v5.min.js"></script>

<link rel="stylesheet" href="java_scripts/bootstrap-multiselect.css">
<link rel="stylesheet" href="java_scripts/bootstrap.min.css">
<script src="java_scripts/jquery-2.2.0.min.js"></script>
<script src="java_scripts/bootstrap.min.js"></script>
<script src="java_scripts/bootstrap-multiselect.js"></script>



<style> /* set the CSS */
body { 
  margin-left: 20px;
}
.p_class { 
  margin-top: 20px;
  margin-left: 20px;
  margin-right: 20px;
  border: 1px solid black ;
}
/* hides the svg dom element that has the click handler responsible for toggling */
#plotdiv .legend .traces:nth-of-type(1) .legendtoggle {
   display: none;
}
/* just for presentation: shows the default cursor insted of the text cursor */
#plotdiv .legend .traces:nth-of-type(2) .legendtext {
   cursor: default;
}
</style>


</head>




<body>



<p class = "p_class"> Forecasts updated July 26, 2020. 
  Click the legend on the right to remove or display each forecast.
  Use the slider bars to see past forecasts and their performace. 
</p>



<div class="plot" id="forecast_div">

</div>



<div class="plot" id="rt_div">

</div>








<script>


function copy(aObject) {
  if (!aObject) {
    return aObject;
  }

  let v;
  let bObject = Array.isArray(aObject) ? [] : {};
  for (const k in aObject) {
    v = aObject[k];
    bObject[k] = (typeof v === "object") ? copy(v) : v;
  }

  return bObject;
}



function unique ( array ) {
    return array.filter(function(a){
        return !this[a] ? this[a] = true : false;
    }, {});
}



function makeplot() {
   Plotly.d3.csv("model_forecasts.csv", function(data1){ 
    Plotly.d3.csv("model_r.csv", function(data2){ 
      Plotly.d3.csv("total_deaths.csv", function(data3){
      processData(data1,data2,data3)
      });
    });
  });
};

//https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/ecdc/total_cases_per_million.csv

// data3 is the total deaths repo
  
function processData(data1,data2,data3) {
  var dates = [];
  var total_count = [];
  for (var i=0; i<data3.length; i++) {
    row = data3[i];
    if(row["Kuwait"] > 0){
        total_count.push(row["Kuwait"])
      // console.log(row)
         dates.push( row["date"] );
    };
  }
  //console.log(dates)
  //console.log(total_count)

  var forecast_dates  = [];
  var forecast_titles = [];

  var forecastTitles = d3.keys(data2[0])
 // console.log(forecastTitles)
  date_name = forecastTitles[0];
  forecastTitles = forecastTitles.slice(1,forecastTitles.length+1);
  //console.log(forecastTitles)
  for (var i=0; i<data2.length; i++) {
    row = data2[i];
    forecast_dates.push(row[date_name])
  }
  //console.log(forecast_dates)

  makePlotly(dates,total_count, data1,data2);
}



function generateRPlot(r_data){
//  console.log(r_data)

  curr_model = r_data[0]["model"]
  yy = []
  xx = []
  val2 = 0; 
  data = []; // will hold all the traces


  for(var i = 0; i < r_data.length; i++){
    row = r_data[i]
    model_name = row["model"]
    if(model_name != curr_model){
      //console.log(curr_model)
      // append the data so far to the current frame
       var trace1 = {
          x: xx, 
          y: yy,
          name:  curr_model, 
          mode: 'lines',
          type: 'scatter',
          line: {
          dash: 'dot'
        } 
      };
      data.push(trace1);
      curr_model = model_name
      yy = []
      xx = []
    };
    val2 = Math.max(val2, row["point"])
    yy.push(row["point"])
    xx.push(row["date"])
  };

  // push the last model
  var trace1 = {
  x: xx, 
  y: yy,
  id: 1,
  name:  curr_model,
  mode: 'lines',
  type: 'scatter',
 line: {
      dash: 'dot'
    }
  }
  data.push(trace1);
  val11 = xx[xx.length-1];
  val10 = "2020-03-08"; // first day of reported Rt
  //console.log(data)


  var layout = {
    title: {
      text:'Reproduction number estimates',
      font: {
        family: 'Arial',
        size: 15
      },
      xref: 'paper',
    },

     legend: {
      //orientation: 'd',
      y: 0.5,
      yref: 'paper',
      font: {
        family: 'Arial',
        size: 15
      },
    bgcolor: '#E2E2E2',
    bordercolor: '#FFFFFF',
    borderwidth: 2
    },
  yaxis: {
    title: {
      text: 'Estimated Rt',
      font: {
        family: 'Arial',
        size: 18,
        color: '#7f7f7f'
      }
    }
  }, 
  shapes: [
  ]
  };



  // add vertical line corresponding to update day
  val1 =  { type: 'line',
    x0: val11,
    y0: 0,
    x1: val11,
    y1: val2,
    line: {
      color: 'rgb(1, 1, 1)',
      width: 1
    }
  };

  // add horizontal line corresponding to Rt = 1
  val2 =  { type: 'line',
    x0: val10,
    y0: 1,
    x1: val11,
    y1: 1,
    line: {
      color: 'rgb(0, 0, 1)',
      width: 0.5
    //  dash: 'dash'
    }
  };

  layout.shapes.push(val1)
  layout.shapes.push(val2)
  var config = {responsive: true}


  Plotly.newPlot('rt_div', data, layout, config);
}


function makePlotly(dates, total_count, forecast_data, r_data){
   generateRPlot(r_data)


  // get all unique forecast dates
  // get all unique models
  forecast_dates = []
  model_names = []
  for(var i =0; i < forecast_data.length; i++){
    row = forecast_data[i]; 
    forecast_dates.push(row["forecast_date"]);
    model_names.push(row["model"])
  }
  forecast_dates = unique(forecast_dates).sort()
  model_names = unique(model_names)



  // get Data by  model_name and forecast date
  function getData(model_name, forecast_date,max_pred){
    trace = {
      x:[],
      y:[],
      name:(model_name)
    }
    for(var i = 0; i < forecast_data.length; i++){
      var row = forecast_data[i]
      if(row["model"] == model_name && row["forecast_date"] == forecast_date){;
        trace.x.push(row["target_week_end_date"])
        trace.y.push(row["point"])
        max_pred = Math.max(max_pred, row["point"])
      }
    }
    return {max_pred: max_pred, trace: trace};
  }


 // console.log(getData("IHME", "2020-07-05"))

  var frames = [] 
  for(var ii = 0; ii < forecast_dates.length; ii++){
    var forecast_date = forecast_dates[ii]
    var traces = []
    var max_pred = 0;
    for(var jj = 0; jj < model_names.length; jj++){
      model_name = model_names[jj]
      res = getData(model_name, forecast_date, max_pred)
      curr_trace = res.trace;
       max_pred = Math.max(max_pred, res.max_pred)
      traces.push(curr_trace)
    }
    //console.log(forecast_date)
    //console.log(max_pred)
    // push the data traces

    dates_prev = [];
    y_prev = [];
    y_future = [];
    dates_future = [];


    six_week_date = new Date(forecast_date)
    six_week_date.setDate(six_week_date.getDate()+42)
    six_week_date = six_week_date.toISOString();
    res = six_week_date.split("T")
    six_week_date = res[0]

    six_week_date_pad = new Date(forecast_date)
    six_week_date_pad.setDate(six_week_date_pad.getDate()+45)
    six_week_date_pad = six_week_date_pad.toISOString();
    res = six_week_date_pad.split("T")
    six_week_date_pad = res[0]

    for(jj = 0; jj < dates.length; jj++){
      if(dates[jj] <= forecast_date){
          dates_prev.push(dates[jj])
          y_prev.push(total_count[jj])
        }
      else if (dates[jj] <= six_week_date){
        dates_future.push(dates[jj])
        y_future.push(total_count[jj]) 
      };
    }



    // past cases
    var trace1 = {
      x: dates_prev.slice(),
      y: y_prev.slice(),
      name: "Reported",
      showlegend: false,
      type: 'scatter',
      mode: 'lines',
      line: {
        color: "black",
        width: 3
      }
    }
    traces.push(trace1)

    // future cases
    var trace2 = {
      x: dates_future.slice(),
      y: y_future.slice(),
      showlegend: false,
      name: "Future reported",
      type: 'scatter',
      mode: 'lines',
      line: {
        color: "gray",
        width: 1,
        dash: 'dashdot'
      }
    };
    traces.push(trace2)
    max_pred = Math.max(max_pred, y_future[y_future.length-1])

    // line marking current day
    var trace3 = {
      x: [forecast_date, forecast_date], 
      y: [0, (y_prev.slice())[y_prev.length-1]],
      mode: 'lines',
      type: 'scatter',
      showlegend: false,
      hoverinfo: 'skip',
      line: {
        color: "black",
        width: 0.5
      }
    }
    traces.push(trace3)

    //console.log(forecast_date)
    //console.log(max_pred)

     var layout = {
    title: {
        text:'COVID-19 Kuwait National Forecasts',
        font: {
          family: 'Arial',
          size: 24
        },
        xref: 'paper',
      },
       legend: {
          y: 0.5,
          yref: 'paper',
          font: {
            family: 'Arial',
            size: 15
          },
        bgcolor: '#E2E2E2',
        bordercolor: '#FFFFFF',
        borderwidth: 2
      },
      yaxis: {
        range: [0, max_pred+20],
        showgrid: true,
        title: {
      text: 'Cumulative detected deaths',
      font: {
        family: 'Arial',
        size: 18,
        color: '#7f7f7f'
      }
    }
      },
      sliders: [{
      active:ii,
      currentvalue: {
        visible: true,
        prefix: 'Forecast week: ',
        xanchor: 'left',
        font: {size: 20, color: '#666'}
      },
      steps: sliderSteps
    }]
    }


    curr_frame = {name:ii, data:traces, layout:layout};
    frames.push(curr_frame)
  }




  //initialize the sliderSteps
  var sliderSteps = [];
    for (ii = 0; ii < forecast_dates.length; ii++) {
      sliderSteps.push({
        method: 'animate',
        label: forecast_dates[ii],
        args: [[ii], {
          frame: {duration: 100, redraw: true, mode: "immediate"},
        }]
      });
    }

//console.log(frames[0])






  // Create the plot starting at the 
  // last slider must copy otherwise problems happen!
  data_copy = copy(frames[frames.length-1].data)
  layout_copy = copy(frames[frames.length-1].layout)

   var layout = {
    title: {
        text:'COVID-19 Kuwait National Forecasts',
        font: {
          family: 'Arial',
          size: 24
        },
        xref: 'paper',
      },
       legend: {
          y: 0.5,
          yref: 'paper',
          font: {
            family: 'Arial',
            size: 15
          },
        bgcolor: '#E2E2E2',
        bordercolor: '#FFFFFF',
        borderwidth: 2
      },
      yaxis: {
        //range: [0, max_pred+20],
        showgrid: true,
        title: {
      text: 'Cumulative detected deaths',
      font: {
        family: 'Arial',
        size: 18,
        color: '#7f7f7f'
      }
    }
      },
      sliders: [{
      active:sliderSteps.length-1,
      currentvalue: {
        visible: true,
        prefix: 'Forecast week: ',
        xanchor: 'left',
        font: {size: 20, color: '#666'}
      },
      steps: sliderSteps
    }]
    }


  var config = {responsive: true}


  Plotly.newPlot('forecast_div', {
    data: data_copy, 
    layout: layout,
    frames: frames,
    config
  });

};

makeplot()

</script>
</body>



<hr>

<ul>


<li> Models make various assumptions about levels of social distancing and other interventions. 
See model descriptions below for details. </li>



 <li> The ensemble model is the median of all other models. It typically performs better than individual models. </li>



<li> We keep track of model performance week-to-week by computing the absolute normalized error of each prediction
against the true number of deaths: (pred-actual)/actual. Displayed in the table below
is the median prediction error for different forecast horizons (e.g. 1 week ahead).
 Prediction error is only displayed if there are at least
3 historic predictions made by that model team for the target horizion, otherwise the table
value is shown as NaN.
</li>

<hr>


<div class="tablediv" id="tablediv">

</div>




<script>
// create the table

var values = [
["Ensemble", "Geneva", "IHME", "Imperial", "LANL", "MIT", "USC", "YYG"],
[2.0, 1.6, 1.0, 0.5, 2.6, 14.7, 1.0, 2.8],[4.9, NaN, 2.3, NaN, 3.3, 30.1, NaN, 4.9],[5.9, NaN, 6.3, NaN, 3.2, 39.5, NaN, 5.9]
]

var headerColor = "grey";
var rowBestColor = "lightblue";
var rowWorstColor = "red";
var rowColor = "white";

var data = [{
  type: 'table',
  header: {
    values: [["<b>Model</b>"], 
    ["<b>1 week ahead median prediction error</b>"],
    ["<b>2 week ahead median prediction error</b>"], 
    ["<b>3 week ahead median prediction error</b>"]
    ],
    align: "center",
    line: {width: 1, color: 'black'},
    fill: {color: headerColor},
    font: {family: "Arial", size: 13, color: "white"}
  },
  cells: {
    values: values,
    align: "center",
    line: {color: "black", width: 1},
    //fill: {color: [[rowBestColor,rowColor,rowColor,rowColor,
    //          rowColor,rowColor,rowWorstColor]]},
    font: {family: "Arial", size: 12, color: ["black"]}
  }
}]

var layout = {
  title: "Historic median prediction errors"
}

var config = {responsive: true}


Plotly.newPlot('tablediv', data, layout, config);


</script>


<hr>

<h2><a id="what-forecasts-predict" class="onThisPageAnchor" title="What the Forecasts Aim to Predict"></a>What the Forecasts Aim to Predict</h2>

<p>Forecasts based on statistical or mathematical models aim to predict changes in national level cumulative reported COVID-19 deaths for the next four weeks. Forecasting teams predict numbers of deaths using different types of data (e.g., COVID-19 data, demographic data, mobility data), methods (see below), and estimates of the impacts of interventions (e.g.&nbsp;social distancing, use of face coverings).</p>
<h2><a id="working" class="onThisPageAnchor" title="Working to Bring Together Forecasts for COVID-19 Deaths in Kuwait"></a>Working to Bring Together Forecasts for COVID-19 Deaths in Kuwait</h2>
<p> These forecasts have been developed independently and shared publicly. It is important to bring these forecasts together to help understand how they compare with each other and how much uncertainty there is about what may happen in the upcoming four weeks.</p>



<h3><a id="imperial-college-london"></a><a href="https://mrc-ide.github.io/covid19-short-term-forecasts/index.html" class="tp-link-policy" data-domain-ext="io">Imperial College, London<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> Imperial</p>
<p><strong>Intervention Assumptions: </strong>These projections do not make specific assumptions about which interventions have been implemented or will remain in place.</p>
<p><strong>Methods:</strong> Ensembles of mechanistic transmission models, fit to different parameter assumptions.</p>
<p><strong>Output:</strong> 1 week ahead deaths, infections, Rt</p>



<h3><a href="https://covid19.healthdata.org/united-states-of-america" class="tp-link-policy" data-domain-ext="org">Institute of Health Metrics and Evaluation<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> IHME</p>
<p><strong>Intervention assumptions: </strong>Projections are adjusted to reflect differences in aggregate population mobility and community mitigation policies.</p>
<p><strong>Methods:</strong> Combination of a mechanistic disease transmission model and a curve-fitting approach</p>
<p><strong>Output:</strong> Deaths, infections, testing, hospital resource use, social distancing</p>



<h3><a id="los-alamos-lab"></a><a href="https://covid-19.bsvgateway.org/" class="tp-link-policy" data-domain-ext="org">Los Alamos National Laboratory<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> LANL</p>
<p><strong>Intervention assumptions: </strong>This model assumes that currently implemented interventions and corresponding reductions in transmission will continue, resulting in an overall decrease in the growth rate of COVID-19. Over the course of the forecast, the model assumes that the rate of growth will decrease over time.</p>
<p><strong>Methods</strong><br>
Statistical dynamical growth model accounting for population susceptibility</p>
<p><strong>Output:</strong> Deaths, infections</p>




<h3><a id="mit"></a><a href="https://www.covidanalytics.io/projections" class="tp-link-policy" data-domain-ext="io">Massachusetts Institute of Technology<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name: </strong>MIT</p>
<p><strong>Intervention Assumptions:</strong> The projections assume that current interventions will remain in place indefinitely.</p>
<p><strong>Methods: </strong>SEIR model fit to reported death and case counts.</p>
<p><strong>Output:</strong> Deaths, infections, active infections, hospitalizations, policy changes</p>



<h3><a id="usc"></a><a href="https://scc-usc.github.io/ReCOVER-COVID-19/" class="tp-link-policy" data-domain-ext="io">University of Southern California<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name: </strong>USC</p>
<p><strong>Intervention Assumptions:</strong> These projections assume that current interventions will remain unchanged during the forecasted period.</p>
<p><strong>Methods:&nbsp;</strong>SIR Model.</p>
<p><strong>Output:</strong> Deaths, infections, R_t</p>


<h3><a id="geneva"></a><a href="https://renkulab.shinyapps.io/COVID-19-Epidemic-Forecasting/" class="tp-link-policy" data-domain-ext="io">University of Geneva / Swiss Data Science Center<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> Geneva</p>
<p><strong>Intervention assumptions: </strong>The projections assume that social distancing policies in place at the date of calibration are extended for the future weeks.</p>
<p><strong>Methods</strong><br>
Exponential and linear statistical models fit to the recent growth rate of cumulative deaths.</p>
<p><strong>Output:</strong> Deaths, infections, R_t</p>


<h3><a id="yyg"></a><a href="http://covid19-projections.com/about/" class="tp-link-policy" data-domain-ext="com">Youyang Gu (COVID-Projections)<span class="sr-only">external icon</span><span class="fi cdc-icon-external x16 fill-external" aria-hidden="true"></span></a></h3>
<p><strong>Model name:</strong> YYG</p>
<p><strong>Intervention assumptions:</strong> The model accounts for reopenings and their impact on infections and deaths.</p>
<p><strong>Methods</strong><br>
SEIS mechanistic model.</p>
</div></div><div class="row "><div class="col-md-12"><div class="row-fluid">
  <div class="vc_empty_space col-12 pb-3"><span class="vc_empty_space_inner"></span></div>
</div>
</div></div></div>
<p><strong>Output:</strong> Deaths, infections, R_t</p>





<hr>

   <footer>
    Please email 
      <a href = "mailto: ahmedmb@gmail.com">Ahmed Bou-Rabee</a> if you would like 
      your projections to be included weekly. Forecasts 
      must be submitted by Sunday at 6 pm AST in order to be included
      in the weekly update.
    </footer>






